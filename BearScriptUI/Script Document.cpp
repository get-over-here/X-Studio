//
// Script Document.cpp : Functions for the creation and display of script document windows
//
// NB: Best viewed with tab size of 3 characters and Visual Studio's 'XML Doc Comment' syntax colouring
//         set to a colour that highly contrasts the 'C/C++ comment' syntax colouring
// 

#include "stdafx.h"

/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                       CONSTANTS / GLOBALS
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

CONST UINT      iLabelsTickerID      = 1;

/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                       CREATION / DESTRUCTION
/// ////////////////////////////////////////////////////////////////////////////////////////////////////



/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                          HELPERS
/// ////////////////////////////////////////////////////////////////////////////////////////////////////


/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                          FUNCTIONS
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

/// Function name  : updateScriptDocumentLabelsCombo
// Description     : Re-Populate the 'Labels' ComboBox using a label data provided by the CodeEdit
// 
// SCRIPT_DOCUMENT*  pDocument : [in] ScriptDocument data
// 
VOID   updateScriptDocumentLabelsCombo(SCRIPT_DOCUMENT*  pDocument)
{
   CODE_EDIT_LOCATION  oCaretLocation;      // Current location of the caret in the CodeEdit
   CODE_EDIT_LABEL*    pCurrentLabel;       // The Label currently being processed
   QUEUE*              pLabelQueue;         // Queue of label names and locations, generated by the CodeEdit
   TCHAR*              szLineNumber;        // One-based line number for display in the ComboBox
   UINT                iNewItemIndex;       // Zero-based ComboBox item index of the item currently being processed

   // Prepare
   TRACK_FUNCTION();
   VERBOSE_LIB_COMMAND();
   szLineNumber = utilCreateEmptyString(32);

   /// Get the label queue and caret location from the CodeEdit
   pLabelQueue = CodeEdit_GetLabelQueue(pDocument->hCodeEdit);
   CodeEdit_GetCaretLocation(pDocument->hCodeEdit, &oCaretLocation);

   // Erase current ComboBox contents
   ComboBox_ResetContent(pDocument->hLabelsCombo);

   /// Add first item '(Global Scope)' and select it
   appendCustomComboBoxItem(pDocument->hLabelsCombo, TEXT("(Global Scope)"));
   ComboBox_SetCurSel(pDocument->hLabelsCombo, 0);
   
   // Iterate through labels in the queue
   while (pCurrentLabel = (CODE_EDIT_LABEL*)popFirstQueueObject(pLabelQueue))
   {
      // Format one-based line number for new ComboItem
      StringCchPrintf(szLineNumber, 32, TEXT("Line %u"), pCurrentLabel->iLineNumber + 1);

      /// Append new ComboItem and store line number as item data
      iNewItemIndex = appendCustomComboBoxItemEx(pDocument->hLabelsCombo, pCurrentLabel->szName, szLineNumber, TEXT("FUNCTION_ICON"), pCurrentLabel->iLineNumber);

      /// Select this label if equal/preceeds the current line
      if (pCurrentLabel->iLineNumber <= oCaretLocation.iLine)
         ComboBox_SetCurSel(pDocument->hLabelsCombo, iNewItemIndex);

      // Cleanup
      deleteCodeEditLabel(pCurrentLabel);
   }
   
   // Cleanup
   utilDeleteString(szLineNumber);
   deleteQueue(pLabelQueue);
   END_TRACKING();
}


/// Function name  : updateScriptDocumentVariablesCombo
// Description     : Fill the variables combo box with a list of variables used in the document
//
// SCRIPT_DOCUMENT*  pDocument : [in] ScriptDocument window data
// 
VOID     updateScriptDocumentVariablesCombo(SCRIPT_DOCUMENT*  pDocument)
{
   VARIABLE_NAME*  pCurrentVariable;      // VariableName currently being processed
   AVL_TREE*       pVariablesTree;        // VariableNames tree for the CodeEdit
   TCHAR*          szVariableCount;       // Number of times the current variable occurs
   UINT            iOriginalSelection;    // Original ComboBox selection index

   // Prepare
   TRACK_FUNCTION();
   VERBOSE_LIB_COMMAND();
   szVariableCount = utilCreateEmptyString(32);

   // Clear combo box
   iOriginalSelection = ComboBox_GetCurSel(pDocument->hVariablesCombo);
   ComboBox_ResetContent(pDocument->hVariablesCombo);

   /// Generate variables tree for document
   pVariablesTree = CodeEdit_GetVariableNameTree(pDocument->hCodeEdit);

   /// [DEFAULT] Add each entry in the tree to the ComboBox
   if (getTreeNodeCount(pVariablesTree) > 0)
   {
      // Add "(Document Variables)" Heading
      appendCustomComboBoxItem(pDocument->hVariablesCombo, TEXT("(Document Variables)"));

      // Iterate through variables tree, backwards
      for (UINT iVariableIndex = 0; findObjectInAVLTreeByIndex(pVariablesTree, iVariableIndex, (LPARAM&)pCurrentVariable); iVariableIndex++)
      {
         // Generate UsageCount text
         StringCchPrintf(szVariableCount, 32, TEXT("%u Uses"), pCurrentVariable->iCount);
         
         /// Append new ComboItem containing <name> and <uses> 
         appendCustomComboBoxItemEx(pDocument->hVariablesCombo, pCurrentVariable->szName, szVariableCount, TEXT("VARIABLE_ICON"), NULL);
      }
   }
   /// [NONE] Display a special heading if there are no variables
   else
      appendCustomComboBoxItem(pDocument->hVariablesCombo, TEXT("(No Document Variables)"));
      
   // Restore original selection
   ComboBox_SetCurSel(pDocument->hVariablesCombo, iOriginalSelection);

   // Cleanup
   utilDeleteString(szVariableCount);
   deleteAVLTree(pVariablesTree);
   END_TRACKING();
}

/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                          MESSAGE HANDLERS
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

/// Function name  : onScriptDocumentContextMenu
// Description     : Display the CodeEdit popup menu
// 
// SCRIPT_DOCUMENT*  pDocument  : [in] ScriptDocument window data
// HWND              hDialog    : [in] ScriptDocument window handle
// CONST POINT*      ptCursor   : [in] Cursor position in screen co-ordinates
// HWND              hCtrl      : [in] Control sending the message
// 
VOID   onScriptDocumentContextMenu(SCRIPT_DOCUMENT*  pDocument, HWND  hDialog, CONST POINT*  ptCursor, HWND  hCtrl)
{
   //GAME_STRING*    pDependency;         // GameString dependency of COMMAND, if any
   CUSTOM_MENU*    pCustomMenu;         // Popup CustomMenu
   CONST TCHAR*    szTargetLabel;       // Name of label targetted by COMMAND, if any
   ERROR_QUEUE*    pErrorQueue;         // CodeEdit line error, if any
   COMMAND*        pCommand;            // CodeEdit line COMMAND

   // Prepare
   TRACK_FUNCTION();
   
   /// [CODE-EDIT]
   if (GetDlgCtrlID(hCtrl) == IDC_CODE_EDIT) 
   {
      // [VERBOSE]
      VERBOSE_LIB_COMMAND();

      /// Create CustomMenu
      pCustomMenu = createCustomMenu(TEXT("SCRIPT_MENU"), TRUE, IDM_CODE_EDIT_POPUP);

      /// [SELECTION] Enable items based on advice from the CodeEdit
      EnableMenuItem(pCustomMenu->hPopup, IDM_EDIT_CUT,    (CodeEdit_HasSelection(pDocument->hCodeEdit) ? MF_ENABLED : MF_DISABLED));
      EnableMenuItem(pCustomMenu->hPopup, IDM_EDIT_COPY,   (CodeEdit_HasSelection(pDocument->hCodeEdit) ? MF_ENABLED : MF_DISABLED));
      EnableMenuItem(pCustomMenu->hPopup, IDM_EDIT_DELETE, (CodeEdit_HasSelection(pDocument->hCodeEdit) ? MF_ENABLED : MF_DISABLED));
      
      // Lookup line COMMAND and ERROR-QUEUE (if any)
      pErrorQueue = CodeEdit_GetCaretLineError(pDocument->hCodeEdit);
      pCommand    = CodeEdit_GetCaretLineCommand(pDocument->hCodeEdit);

      // [CHECK] Ensure command exists
      ASSERT(pCommand);

      // [CHECK] Are there no errors?
      if (!pErrorQueue)
      {
         removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_ERROR, FALSE);        // [FIX] BUG:1030 'CodeEdit context menu item 'View Error' has the wrong icon and doesn't be reflect severity of the actual error'
         removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_WARNING, FALSE);
      }
      else
         /// [ERROR/WARNING] Display item with correct severity
         removeCustomMenuItem(pCustomMenu->hPopup, (identifyErrorQueueType(pErrorQueue) == ET_ERROR ? IDM_CODE_EDIT_VIEW_WARNING : IDM_CODE_EDIT_VIEW_ERROR), FALSE);

      // [CHECK] Is this auxiliary/expression command?
      if (isCommandType(pCommand, CT_AUXILIARY) OR isCommandID(pCommand, CMD_EXPRESSION))
         removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_LOOKUP_COMMAND, FALSE); 
      else
         /// [COMMAND HELP] Is MSCI URL present?
         EnableMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_LOOKUP_COMMAND, isCommandReferenceURLPresent(pCommand->pSyntax) ? MF_ENABLED : MF_DISABLED);

      /// [SUGGESTIONS] Are suggestions available?
      EnableMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_SUGGESTIONS, (CodeEdit_HasSuggestions(pDocument->hCodeEdit) ? MF_ENABLED : MF_DISABLED));

      // [CHECK] Is this a script-call command?
      if (!isCommandType(pCommand, CT_SCRIPTCALL))
         removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_OPEN_TARGET_SCRIPT, FALSE);
      else
         /// [SCRIPT-CALL] Always enable
         EnableMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_OPEN_TARGET_SCRIPT, MF_ENABLED);

      // [CHECK] Is this goto label or goto sub command?
      if (isCommandGotoLabel(pCommand, szTargetLabel))
      {
         /// [GOTO SUB/LABEL] Always enable
         EnableMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_GOTO_LABEL, MF_ENABLED);
         setCustomMenuItemText(pCustomMenu->hMenuBar, IDM_CODE_EDIT_GOTO_LABEL, FALSE, TEXT("View %s '%s'"), isCommandID(pCommand, CMD_GOTO_LABEL) ? TEXT("Label") : TEXT("Subroutine"), szTargetLabel);
      }
      else
         removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_GOTO_LABEL, FALSE);
      
      // [CHECK] Does command use GameStrings?
      if (!isCommandGameStringDependent(pCommand))
         removeCustomMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_LANGUAGE_STRING, FALSE);  
      else
      {
         /// [VIEW STRING] Is dependency present?
         //BOOL bEnabled = (getActiveProject() ? CodeEdit_FindGameString(pDocument->hCodeEdit, getActiveProject(), pDependency) : findGameStringDependency(pCommand, pDependency));
         //pDependency = CodeEdit_GetCaretGameString(pDocument->hCodeEdit, getActiveProjectFile());
         EnableMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_VIEW_LANGUAGE_STRING, CodeEdit_GetCaretGameString(pDocument->hCodeEdit, getActiveProjectFile()) ? MF_ENABLED : MF_DISABLED);
      }
         
      /// [PROPERTIES] Check based on whether the window is open or not
      CheckMenuItem(pCustomMenu->hPopup, IDM_CODE_EDIT_PROPERTIES, (getMainWindowData()->hPropertiesSheet ? MF_CHECKED : MF_UNCHECKED));
      
      // Display the pop-up menu
      TrackPopupMenu(pCustomMenu->hPopup, TPM_LEFTALIGN WITH TPM_TOPALIGN WITH TPM_LEFTBUTTON, ptCursor->x, ptCursor->y, NULL, hDialog, NULL);
      deleteCustomMenu(pCustomMenu);
   }

   // [TRACK]
   END_TRACKING();
}

/// Function name  : onScriptDocumentCommand
// Description     : Handle notifications from the child controls
//
// SCRIPT_DOCUMENT*  pDocument     : [in] Document data
// CONST UINT        iControlID    : [in] ID of the control sending the notification
// CONST UINT        iNotification : [in] Notification code
// 
// Return type : TRUE if processed, FALSE if not
//
BOOL   onScriptDocumentCommand(SCRIPT_DOCUMENT*  pDocument, CONST UINT  iControlID, CONST UINT  iNotification)
{
   UINT    iLabelLineNumber;
   BOOL    bResult;

   // [TRACK]
   TRACK_FUNCTION();
   bResult = TRUE;
   
   switch (iControlID)
   {
   /// [VARIABLES COMBO-BOX]
   case IDC_VARIABLES_COMBO:
      switch (iNotification)
      {
      // [OPEN] Populate with all the variables in the CodeEdit
      case CBN_DROPDOWN:
         updateScriptDocumentVariablesCombo((SCRIPT_DOCUMENT*)pDocument);
         break;

      // [CLOSE] Return focus to the CodeEdit
      case CBN_CLOSEUP:
         SetFocus(pDocument->hCodeEdit);
         break;

      // [UNHANDLED]
      default:
         bResult = FALSE;
         break;
      }
      break;

   /// [LABELS COMBOBOX]
   case IDC_LABELS_COMBO:
      switch (iNotification)
      {
      // [OPEN] Populate with all the labels in the CodeEdit
      case CBN_DROPDOWN:
         updateScriptDocumentLabelsCombo((SCRIPT_DOCUMENT*)pDocument);
         break;

      // [CLICK] Scroll the CodeEdit to the desired label
      case CBN_SELCHANGE:
         // Lookup label Line number, stored as item data
         iLabelLineNumber = getCustomComboBoxItemParam(pDocument->hLabelsCombo, ComboBox_GetCurSel(pDocument->hLabelsCombo));
         // Scroll CodeEdit to the label 
         CodeEdit_ScrollToLocation(pDocument->hCodeEdit, 0, iLabelLineNumber);

         // Pass focus to the CodeEdit
         SetFocus(pDocument->hCodeEdit);
         break;

      // [UNHANDLED]
      default:
         bResult = FALSE;
         break;
      }
      break;

   /// [CUT/COPY/PASTE/DELETE]
   case IDM_EDIT_CUT:                        SendMessage(pDocument->hCodeEdit, WM_CUT, NULL, NULL);      break;
   case IDM_EDIT_COPY:                       SendMessage(pDocument->hCodeEdit, WM_COPY, NULL, NULL);     break;
   case IDM_EDIT_PASTE:                      SendMessage(pDocument->hCodeEdit, WM_PASTE, NULL, NULL);    break;
   case IDM_EDIT_DELETE:                     SendMessage(pDocument->hCodeEdit, WM_CLEAR, NULL, NULL);    break;

   /// [SELECT ALL/COMMENT/SUGGESTIONS]
   case IDM_EDIT_SELECT_ALL:                 CodeEdit_SelectAll(pDocument->hCodeEdit);                                                                break;
   case IDM_EDIT_COMMENT:                    CodeEdit_CommentSelection(pDocument->hCodeEdit, !CodeEdit_IsSelectionCommented(pDocument->hCodeEdit));   break;
   case IDM_CODE_EDIT_VIEW_SUGGESTIONS:      CodeEdit_ShowSuggestions(pDocument->hCodeEdit, NULL);                                                    break;

   /// [MSCI/VIEW-ERROR/OPEN-SCRIPT/GOTO-LABEL/VIEW-STRING]
   case IDM_CODE_EDIT_LOOKUP_COMMAND:        onScriptDocumentLookupCommand(pDocument);       break;
   case IDM_CODE_EDIT_VIEW_ERROR:
   case IDM_CODE_EDIT_VIEW_WARNING:          onScriptDocumentViewError(pDocument);           break;
   case IDM_CODE_EDIT_OPEN_TARGET_SCRIPT:    onScriptDocumentOpenTargetScript(pDocument);    break;
   case IDM_CODE_EDIT_GOTO_LABEL:            onScriptDocumentGotoLabel(pDocument);           break;
   case IDM_CODE_EDIT_VIEW_LANGUAGE_STRING:  onScriptDocumentViewLanguageString(pDocument);  break;

   /// [PROPERTIES]
   case IDM_CODE_EDIT_PROPERTIES:            SendMessage(getAppWindow(), WM_COMMAND, IDM_VIEW_DOCUMENT_PROPERTIES, NULL);  break;
   }

   // [TRACK]
   END_TRACKING();
   return bResult;
}



/// Function name  : createScriptDialogControls
// Description     : 
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// 
VOID  createScriptDialogControls(SCRIPT_DOCUMENT*  pDocument)
{
   PANE_PROPERTIES   oPaneData;       // New pane properties
   PANE*             pTargetPane;     // Workspace pane being targetted for a split
   RECT              rcDialog;        // Dialog client rectangle
   SIZE              siDialog,        // Size of dialog rectangle
                     siComboBox;      // Size of ComboBox

   // Prepare
   TRACK_FUNCTION();
   GetClientRect(pDocument->hWnd, &rcDialog);
   utilConvertRectangleToSize(&rcDialog, &siDialog);

   /// [LABELS COMBO]
   pDocument->hLabelsCombo = CreateWindow(WC_COMBOBOX, TEXT("Labels Combo"), WS_CHILD WITH WS_TABSTOP WITH WS_VSCROLL WITH CBS_DROPDOWNLIST WITH CBS_OWNERDRAWFIXED, 0, 0, (siDialog.cx / 2), ITS_MEDIUM,
                                          pDocument->hWnd, (HMENU)IDC_LABELS_COMBO, getAppInstance(), NULL);
   ERROR_CHECK("Creating Labels ComboBox", pDocument->hLabelsCombo);

   /// [VARIABLES COMBO]
   pDocument->hVariablesCombo = CreateWindow(WC_COMBOBOX, TEXT("Variables Combo"), WS_CHILD WITH WS_TABSTOP WITH WS_VSCROLL WITH CBS_DROPDOWNLIST WITH CBS_OWNERDRAWFIXED, (siDialog.cx / 2), 0, (siDialog.cx / 2), ITS_MEDIUM, 
                                             pDocument->hWnd, (HMENU)IDC_VARIABLES_COMBO, getAppInstance(), NULL);
   ERROR_CHECK("Creating Variables ComboBox", pDocument->hVariablesCombo);

   /// [CODE EDIT]
   pDocument->hCodeEdit = CreateWindow(szCodeEditClass, TEXT("CodeEdit"), WS_CHILD WITH WS_TABSTOP, 0, 0, 400, 400, 
                                       pDocument->hWnd, (HMENU)IDC_CODE_EDIT, getControlsInstance(), NULL);
   ERROR_CHECK("Creating CodeEdit", pDocument->hCodeEdit);

   // Set ComboBox fonts
   SetWindowFont(pDocument->hLabelsCombo, GetStockFont(ANSI_VAR_FONT), FALSE);
   SetWindowFont(pDocument->hVariablesCombo, GetStockFont(ANSI_VAR_FONT), FALSE);

   // Measure ComboBox
   utilGetWindowSize(pDocument->hLabelsCombo, &siComboBox);

   /// Create workspace and insert CodeEdit
   pDocument->hWorkspace = createWorkspace(pDocument->hWnd, &rcDialog, pDocument->hCodeEdit, IsThemeActive() ? COLOR_WINDOW : COLOR_BTNFACE);

   // Search for CodeEdit pane
   if (findWorkspacePaneByHandle(pDocument->hWorkspace, pDocument->hCodeEdit, NULL, NULL, pTargetPane))
   {
      /// Add Labels Combo in a vertical split with the CodeEdit
      setWorkspacePaneProperties(&oPaneData, TRUE, siComboBox.cy, NULL);
      insertWorkspaceWindow(pDocument->hWorkspace, pTargetPane, pDocument->hLabelsCombo, TOP, &oPaneData);
   }
   
   // Search for the Labels pane
   if (findWorkspacePaneByHandle(pDocument->hWorkspace, pDocument->hLabelsCombo, NULL, NULL, pTargetPane))
   {
      /// Add the Variables Combo in a horizontal split with the Labels Combo
      setWorkspacePaneProperties(&oPaneData, TRUE, NULL, 0.5f);
      insertWorkspaceWindow(pDocument->hWorkspace, pTargetPane, pDocument->hVariablesCombo, RIGHT, &oPaneData);
   }

   // [TRACK]
   END_TRACKING();
}


/// Function name  : onScriptDocumentCreate
// Description     : Initialises the ScriptDocument controls and the ScriptDocument convenience pointers.
// 
// SCRIPT_DOCUMENT*  pDocument : [in] ScriptDocument data
// HWND              hDialog   : [in] Document window handle
// 
VOID   onScriptDocumentCreate(SCRIPT_DOCUMENT*  pDocument, HWND  hDialog)
{  
   // [TRACK]
   TRACK_FUNCTION();

   // Associate data with dialog
   SetWindowLong(hDialog, 0, (LONG)pDocument);
   pDocument->hWnd = hDialog;

   // Create document convenience pointer
   pDocument->pScriptFile = (SCRIPT_FILE*)pDocument->pGameFile;

   /// Create child windows
   createScriptDialogControls(pDocument);
   
   /// Initialise Labels Combo
   appendCustomComboBoxItem(pDocument->hLabelsCombo, TEXT("(Global Scope)"));
   ComboBox_SetCurSel(pDocument->hLabelsCombo, 0);
   ComboBox_SetMinVisible(pDocument->hLabelsCombo, 6);

   /// Initialise Variables Combo
   appendCustomComboBoxItem(pDocument->hVariablesCombo, TEXT("(Document Variables)"));
   ComboBox_SetCurSel(pDocument->hVariablesCombo, 0);
   ComboBox_SetMinVisible(pDocument->hVariablesCombo, 10);

   /// Display Script
   CodeEdit_SetScriptFile(pDocument->hCodeEdit, pDocument->pScriptFile);

   // Show windows
   ShowWindow(pDocument->hLabelsCombo, SW_SHOWNORMAL);
   ShowWindow(pDocument->hVariablesCombo, SW_SHOWNORMAL);
   ShowWindow(pDocument->hCodeEdit, SW_SHOWNORMAL);

   // [TRACK]
   END_TRACKING();
}


/// Function name  : onScriptDocumentDestroy
// Description     : Destroy the data contained within the document but not the data structure itself
//
// SCRIPT_DOCUMENT*  pDocument : [in] Script document
// 
VOID     onScriptDocumentDestroy(SCRIPT_DOCUMENT*  pDocument)
{
   // [TRACK]
   TRACK_FUNCTION();

   // Delete ticker
   KillTimer(pDocument->hWnd, iLabelsTickerID);
   
   // Destroy workspace
   utilDeleteWindow(pDocument->hWorkspace);

   /// Window data is destroyed by documents control
#ifdef BUG_FIX
   SetWindowLong(pDocument->hWnd, DWL_USER, NULL);    // BUG:001 caused by deleting the data within this context
   utilDeleteObject(pDocument);
#endif

   // [TRACK]
   END_TRACKING();
}


/// Function name  : onScriptDocumentGetScriptVersion
// Description     : Returns the Script's GameVersion 
// 
// SCRIPT_DOCUMENT*  pDocument : [in]  Script Document data
// GAME_VERSION*     pOutput   : [out] Script GameVersion
// 
// Return Value : TRUE
//
BOOL   onScriptDocumentGetScriptVersion(SCRIPT_DOCUMENT*  pDocument, GAME_VERSION*  pOutput)
{
   // [CHECK] Ensure output exists
   TRACK_FUNCTION();
   ASSERT(pOutput);
   
   /// Set GameVersion
   (*pOutput) = pDocument->pScriptFile->eGameVersion;

   // [TRACK]
   END_TRACKING();
   return TRUE;
}


/// Function name  : onScriptDocumentGotoLabel
// Description     : 
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// 
VOID  onScriptDocumentGotoLabel(SCRIPT_DOCUMENT*  pDocument)
{
   CODE_EDIT_LABEL*  pLabel;
   CONST TCHAR*      szTargetLabel;
   COMMAND*          pCommand;        // COMMAND containing the script call
   QUEUE*            pLabelQueue;
   BOOL              bFound;

   // [TRACK]
   TRACK_FUNCTION();

   // Retrieve the COMMAND containing the script call
   pCommand = CodeEdit_GetCaretLineCommand(pDocument->hCodeEdit);
   ASSERT(pCommand);

   // [CHECK] Ensure COMMAND is 'goto label' or 'gosub' and extract label name
   if (isCommandGotoLabel(pCommand, szTargetLabel))
   {
      // Prepare
      pLabelQueue = CodeEdit_GetLabelQueue(pDocument->hCodeEdit);
      bFound      = FALSE;

      // Examine all labels within the document
      while (!bFound AND (pLabel = (CODE_EDIT_LABEL*)popFirstQueueObject(pLabelQueue)))
      {
         /// [LABEL] Scroll CodeEdit to the correct label
         if (bFound = utilCompareStringVariables(pLabel->szName, szTargetLabel))
            CodeEdit_ScrollToLocation(pDocument->hCodeEdit, 0, pLabel->iLineNumber);
         
         // Cleanup
         deleteCodeEditLabel(pLabel);
      }

      // Cleanup
      deleteQueue(pLabelQueue);
   }

   // Cleanup
   END_TRACKING();
}


/// Function name  : onScriptDocumentHelp
// Description     : Launch the appropriate help page for the currently selected control 
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script Document data
// HWND              hDialog   : [in] Script document window handle
// CONST HELPINFO*   pRequest  : [in] System WM_HELP data
// 
VOID  onScriptDocumentHelp(SCRIPT_DOCUMENT*  pDocument, HWND  hDialog, CONST HELPINFO*  pRequest)
{
   switch (pRequest->iCtrlId)
   {
   case IDC_LABELS_COMBO:     
   case IDC_VARIABLES_COMBO:  displayHelp(TEXT("MSCI_LabelsVariables"));  break;
   case IDC_CODE_EDIT:        displayHelp(TEXT("MSCI_Overview"));         break;
   }
}


/// Function name  : onScriptDocumentLoadComplete
// Description     : Recursively opens script-calls, or performs automatic compilation
// 
// SCRIPT_DOCUMENT*     pDocument      : [in] Script document
// DOCUMENT_OPERATION*  pOperationData : [in] Generation Operation Data
// 
VOID   onScriptDocumentLoadComplete(SCRIPT_DOCUMENT*  pDocument, DOCUMENT_OPERATION*  pOperationData)
{
   SCRIPT_DEPENDENCY  *pDependency;          // Depdency being loaded
   LOADING_OPTIONS     oLoadingOptions;      // Advanced load/save options
   ERROR_STACK        *pError;               // Operation error
   AVL_TREE           *pDependenciesTree;    // Script Dependencies tree
   TCHAR              *szScriptPath,         // Full path of script being tested/loaded
                      *szScriptFolder;       // Folder containing script being tested

   // [TRACK]
   TRACK_FUNCTION();

   /// [MODIFIED on LOAD] 
   if (pDocument->pScriptFile->bModifiedOnLoad)
      setDocumentModifiedFlag(pDocument, TRUE);

   /// [RECURSION] Are we opening script dependencies?
   if (pOperationData->oAdvanced.iRecursionDepth > 0)
   {
      // Generate dependencies tree
      pDependenciesTree = CodeEdit_GetScriptDependencyTree(pDocument->hCodeEdit);

      /// Decrease recursion depth
      oLoadingOptions = pOperationData->oAdvanced;
      oLoadingOptions.iRecursionDepth--;

      /// Iterate through dependencies
      for (UINT  iIndex = 0; findObjectInAVLTreeByIndex(pDependenciesTree, iIndex, (LPARAM&)pDependency); iIndex++)
      {
         // Generate full filepath with .pck extension
         szScriptPath = utilRenameFilePath(pDocument->pScriptFile->szFullPath, pDependency->szScriptName);
         StringCchCat(szScriptPath, MAX_PATH, TEXT(".pck"));

         /// Attempt to open .pck / .xml version of script
         if (!commandLoadScriptDependency(getMainWindowData(), szScriptPath, FALSE, &oLoadingOptions))  
         {
            // [WARNING] "The script dependency '%s' could not be found in the folder containing the script '%s'"
            pError = generateDualWarning(HERE(IDS_GENERAL_DEPENDENCY_NOT_FOUND), pDependency->szScriptName, pDocument->pScriptFile->szScriptname);
            // Display in output dialog
            printErrorToOutputDialog(pError);
            deleteErrorStack(pError);
         }

         // Cleanup
         utilDeleteString(szScriptPath);
      }

      // Cleanup
      deleteAVLTree(pDependenciesTree);
   }
   /// [GENERATION TEST] Are we performing a compilation test?
   else if (pOperationData->oAdvanced.eCompilerTest == ODT_GENERATION)
   {
      /// Preserve document filename but save into a 'Validation' sub-folder and ensure extension is XML
      szScriptPath = utilCreateStringf(MAX_PATH, TEXT("%sCode.Validation\\%s"), szScriptFolder = utilDuplicateFolderPath(getDocumentPath(pDocument)), getDocumentFileName(pDocument));
      PathRenameExtension(szScriptPath, TEXT(".xml"));
      setDocumentPath(pDocument, szScriptPath);

      /// Save document, Close if successful
      commandSaveDocument(getMainWindowData(), pDocument, TRUE, &pOperationData->oAdvanced);    // Pass existing batch file data, if any

      // Cleanup
      utilDeleteStrings(szScriptPath, szScriptFolder);
   }

   // [TRACK]
   END_TRACKING();
}


/// Function name  : onScriptDocumentLookupCommand
// Description     : Displays MSCI reference URL
// 
// SCRIPT_DOCUMENT*  pDocument : [in] ScriptDocument
// 
VOID  onScriptDocumentLookupCommand(SCRIPT_DOCUMENT*  pDocument)
{
   COMMAND*    pCommand;          // CodeEdit line COMMAND
   
   // Lookup COMMAND
   pCommand = CodeEdit_GetCaretLineCommand(pDocument->hCodeEdit);

   // [CHECK] Ensure command has URL
   if (pCommand AND isCommandReferenceURLPresent(pCommand->pSyntax))
      /// [FOUND] Launch MSCI reference URL
      utilLaunchURL(getAppWindow(), pCommand->pSyntax->szReferenceURL, SW_SHOWMAXIMIZED);
}


/// Function name  : onScriptDocumentLoseFocus
// Description     : Destroy the 'Current scope' ticker
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// HWND              hDialog   : [in] 
// 
VOID  onScriptDocumentLoseFocus(SCRIPT_DOCUMENT*  pDocument, HWND  hDialog)
{
   // [TRACK]
   TRACK_FUNCTION();
   
   // Destroy labels refresh timer
   KillTimer(pDocument->hWnd, iLabelsTickerID);

   // [TRACK]
   END_TRACKING();
}


/// Function name  : onScriptDocumentNotify
// Description     : WM_NOTIFY handler for documents
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// NMHDR*            pMessage  : [in] 
//
// Return Type : TRUE if processed, FALSE otherwise
// 
BOOL   onScriptDocumentNotify(SCRIPT_DOCUMENT*  pDocument, NMHDR*  pMessage)
{
   // [CUSTOM DRAW]
   if (pMessage->code == NM_CUSTOMDRAW)
   {
      CONSOLE("Custom draw hwnd = %08u", pMessage->hwndFrom);
   }

   return FALSE;
}


/// Function name  : onScriptDocumentPreferencesChanged
// Description     : Loads the script specified in the script call command at the caret
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script document
// 
VOID  onScriptDocumentOpenTargetScript(SCRIPT_DOCUMENT*  pDocument)
{
   COMMAND*  pCommand;        // COMMAND containing the script call
   TCHAR*    szTargetPath;    // Full path of the target script

   // [TRACK]
   TRACK_FUNCTION();

   // Retrieve the COMMAND containing the script call
   pCommand = CodeEdit_GetCaretLineCommand(pDocument->hCodeEdit);
   ASSERT(pCommand);

   // Attempt to generate the full path of the specified script  (Fails if script name is a variable)
   szTargetPath = calculateScriptCallTargetFilePath(pDocument->pScriptFile->szFullPath, pCommand); 

   /// Attempt to first load load .pck then .xml version of script
   if (szTargetPath AND !commandLoadScriptDependency(getMainWindowData(), szTargetPath, TRUE, NULL))
   {
      // Remove '.pck' extension from path for display purposes
      utilFindCharacterReverse(szTargetPath, '.')[0] = NULL;

      // [ERROR] "The script dependency '%s' could not be found in the folder containing the script '%s'"
      displayMessageDialogf(NULL, IDS_GENERAL_DEPENDENCY_NOT_FOUND, TEXT("Script Dependency Not Found"), MDF_OK WITH MDF_ERROR, PathFindFileName(szTargetPath), pDocument->pScriptFile->szScriptname);
   }

   // Cleanup
   utilSafeDeleteString(szTargetPath);
   END_TRACKING();
}


/// Function name  : onScriptDocumentPreferencesChanged
// Description     : Refresh the CodeEdit
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// 
VOID   onScriptDocumentPreferencesChanged(SCRIPT_DOCUMENT*  pDocument)
{
   /// Pass new preferences to the CodeEdit
   CodeEdit_SetPreferences(pDocument->hCodeEdit, getAppPreferences());
}


/// Function name  : onScriptDocumentQueryCommand
// Description     : Determines whether a toolbar/menu command relating to the document should be enabled or disabled
// 
// SCRIPT_DOCUMENT*  pDocument   : [in] Script Document to query
// CONST UINT        iCommandID  : [in] Menu/toolbar Command to query
// 
// Message Return Value : Combination of MF_ENABLED, MF_DISABLED, MF_CHECKED, MF_UNCHECKED
// 
UINT   onScriptDocumentQueryCommand(SCRIPT_DOCUMENT*  pDocument, CONST UINT  iCommandID)
{
   UINT  iState;    // Operation result

   // [TRACKING]
   TRACK_FUNCTION();

   // Examine command
   switch (iCommandID)
   {
   /// [UNDO/REDO] Query CodeEdit
   case IDM_EDIT_REDO:  iState = (SendMessage(pDocument->hCodeEdit, EM_CANREDO, NULL, NULL) ? MF_ENABLED : MF_DISABLED);   break;
   case IDM_EDIT_UNDO:  iState = (SendMessage(pDocument->hCodeEdit, EM_CANUNDO, NULL, NULL) ? MF_ENABLED : MF_DISABLED);   break;  

   /// [CUT/COPY/DELETE] Requires a text selection
   case IDM_EDIT_CUT:
   case IDM_EDIT_COPY:
   case IDM_EDIT_DELETE:
   case IDM_EDIT_COMMENT:
      iState = (SendMessage(pDocument->hCodeEdit, UM_HAS_SELECTION, NULL, NULL) ? MF_ENABLED : MF_DISABLED);
      break;

   /// [PASTE / SELECT ALL] Always enabled
   case IDM_EDIT_PASTE:
   case IDM_EDIT_SELECT_ALL:
      iState = MF_ENABLED;
      break;

   // [UNSUPPORTED] Error
   default:
      ASSERT(FALSE);
      break;
   }

   // Set message result
   END_TRACKING();
   return iState;
}


/// Function name  : onScriptDocumentReceiveFocus
// Description     : Create the 'Current scope' timer
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// HWND              hDialog   : [in] 
// 
VOID  onScriptDocumentReceiveFocus(SCRIPT_DOCUMENT*  pDocument, HWND  hDialog)
{
   // [TRACK]
   TRACK_FUNCTION();

   // Setup labels refresh timer
   SetTimer(pDocument->hWnd, iLabelsTickerID, 2000, NULL);

   // Set focus to the CodeEdit
   SetFocus(pDocument->hCodeEdit);

   // [TRACK]
   END_TRACKING();
}


/// Function name  : onScriptDocumentResize
// Description     : Resizes a script document and repositions it's child windows
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script document
// CONST SIZE*       pNewSize  : [in] New window size
// 
VOID   onScriptDocumentResize(SCRIPT_DOCUMENT*  pDocument, CONST SIZE*  pNewSize)
{
   // [TRACK]
   TRACK_FUNCTION();

   // Resize workspace
   SetWindowPos(pDocument->hWorkspace, NULL, NULL, NULL, pNewSize->cx, pNewSize->cy, SWP_NOMOVE WITH SWP_NOZORDER);

   // [TRACK]
   END_TRACKING();
}


/// Function name  : onScriptDocumentRequestArguments
// Description     : 
// 
// SCRIPT_DOCUMENT*  pDocument : [in] 
// CONST COMMAND*    pCommand  : [in] 
// 
VOID  onScriptDocumentRequestArguments(SCRIPT_DOCUMENT*  pDocument, CONST COMMAND*  pCommand)
{
   SCRIPT_FILE*  pTargetScript;
   ERROR_QUEUE*  pErrorQueue;
   ARGUMENT*     pArgument;
   TCHAR*        szOutput;

   // Prepare
   szOutput = utilCreateEmptyString(LINE_LENGTH);

   // [CHECK] Attempt to load the script properties into a new ScriptFile
   if (loadScriptCallCommandTargetScript(pDocument->pScriptFile, pCommand, pDocument->hWnd, pTargetScript, pErrorQueue = createErrorQueue()))
   {
      // [SUCCESS] Generate arguments string
      for (UINT  iIndex = 0; findArgumentInScriptFileByIndex(pTargetScript, iIndex, pArgument); iIndex++)
         utilStringCchCatf(szOutput, LINE_LENGTH, TEXT(" %s=%s"), pArgument->szName, identifyParameterSyntaxDefaultValue(pArgument->eType));
    
      // Insert into CodeEdit
      StringCchCat(szOutput, LINE_LENGTH, TEXT(" "));
      CodeEdit_InsertTextAtCaret(pDocument->hCodeEdit, szOutput);

      // Cleanup
      deleteScriptFile(pTargetScript);
   }

   // Cleanup
   utilDeleteString(szOutput);
   deleteErrorQueue(pErrorQueue);
}


/// Function name  : onScriptDocumentSaveComplete
// Description     : Marks the document as 'un-modified' if successful
// 
// SCRIPT_DOCUMENT*     pDocument      : [in] Script document
// DOCUMENT_OPERATION*  pOperationData : [in] Generation Operation Data
// 
VOID   onScriptDocumentSaveComplete(SCRIPT_DOCUMENT*  pDocument, DOCUMENT_OPERATION*  pOperationData)
{
   LOADING_OPTIONS  oOptions;          // Advance loading options

   // [TRACK]
   TRACK_FUNCTION();

   /// [SUCCESSFUL] Document saved successfully
   if (isOperationSuccessful(pOperationData))
   {
      /// [UN-MODIFIED] Remove 'modified' flag
      setDocumentModifiedFlag(pDocument, FALSE);

      // [COMPILER TEST] Validate the generated document
      if (pOperationData->oAdvanced.eCompilerTest == ODT_GENERATION)
      {
         // Prepare
         oOptions = pOperationData->oAdvanced;

         // [VALIDATE] Switch to validation mode
         oOptions.eCompilerTest = ODT_VALIDATION;

         /// [SINGLE] Re-open original file in validation mode
         commandLoadDocument(getMainWindowData(), FIF_SCRIPT, oOptions.szOriginalPath, TRUE, &oOptions);
      }
   }
   /// [FAILED] 
   else 
   {
      // [CHECK] Are we batch testing?
      if (pOperationData->oAdvanced.bBatchCompilerTest)
         /// [BATCH TESTING] Stop batch test
         commandScriptValidationBatchTest(getMainWindowData(), BTC_STOP);
   }

   // Refresh CodeEdit
   InvalidateRect(pDocument->hCodeEdit, NULL, FALSE);
   
   // [TRACK]
   END_TRACKING();
}


/// Function name  : onScriptDocumentScopeChange
// Description     : Updates the scope combobox
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script document
// CODE_EDIT_LABEL*  pNewScope : [in] New scope
// 
VOID  onScriptDocumentScopeChange(SCRIPT_DOCUMENT*  pDocument, CODE_EDIT_LABEL*  pNewScope)
{
   // Update labels and display current scope
   updateScriptDocumentLabelsCombo(pDocument);
}


/// Function name  : onScriptDocumentSelectionChange
// Description     : Update the main window's toolbar
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script Document
// 
VOID  onScriptDocumentSelectionChange(SCRIPT_DOCUMENT*  pDocument)
{
   // Update main window toolbar to reflect current selection
   updateMainWindowToolBar(getMainWindowData());
}


/// Function name  : onScriptDocumentTextChange
// Description     : Inform main window the document has changed
// 
// SCRIPT_DOCUMENT*  pDocument : [in] Script document
// 
VOID  onScriptDocumentTextChange(SCRIPT_DOCUMENT*  pDocument)
{
   // Inform main window that the underlying document data has changed
   sendDocumentUpdated(AW_DOCUMENTS_CTRL);
}


/// Function name  : onScriptDocumentPropertyChanged
// Description     : Refresh CodeEdit when arguments change
//
// SCRIPT_DOCUMENT*  pDocument  : [in] Document that has been updated
// CONST UINT        iControlID : [in] ID of the control responsible for the change
// 
VOID  onScriptDocumentPropertyChanged(SCRIPT_DOCUMENT*  pDocument, CONST UINT  iControlID)
{
   // [ARGUMENTS CHANGED] Refresh CodeEdit
   if (iControlID == IDC_ARGUMENTS_LIST)
      InvalidateWindow(pDocument->hCodeEdit, FALSE);
}

/// Function name  : onScriptDocumentValidationComplete
// Description     : Moves to the next script in the batch test.
///                                       Note: When validation is successful, the document does not actually exist
// 
// SCRIPT_DOCUMENT*     pDocument      : [in] Script Document, if failed, otherwise NULL
// DOCUMENT_OPERATION*  pOperationData : [in] Generation Operation Data
// 
VOID   onScriptDocumentValidationComplete(SCRIPT_DOCUMENT*  pDocument, DOCUMENT_OPERATION*  pOperationData)
{
   // [TRACK]
   TRACK_FUNCTION();

   /// [SUCCESSFUL] Validation successful
   if (isOperationSuccessful(pOperationData))
   {
      // [CHECK] Document does not actually exist
      ASSERT(pDocument == NULL);

      // [CHECK] Are we batch testing?
      if (pOperationData->oAdvanced.bBatchCompilerTest)
         /// [BATCH TESTING] Load the next document in the sequence
         commandScriptValidationBatchTest(getMainWindowData(), BTC_NEXT_FILE);
   }
   /// [FAILED] 
   // Do nothing

   // [TRACK]
   END_TRACKING();
}


/// Function name  : onScriptDocumentViewLanguageString
// Description     : Display the string referenced by the command on the current line
// 
// SCRIPT_DOCUMENT*    pDocument   : [in] ScriptDocument
// 
VOID  onScriptDocumentViewLanguageString(SCRIPT_DOCUMENT*  pDocument)
{
   GAME_STRING*  pDependency;
   //COMMAND*      pCommand = CodeEdit_GetCaretLineCommand(pDocument->hCodeEdit);

   // [CHECK] Lookup Dependency
   //if (findGameStringDependency(pCommand, pDependency))
   if (pDependency = CodeEdit_GetCaretGameString(pDocument->hCodeEdit, getActiveProjectFile()))
   {
      /// Load/Display game strings
      onMainWindowDataGameStrings(getMainWindowData());

      // Select desired GameString
      displayLanguageDocumentGameString(getActiveLanguageDocument(), pDependency);
   }
}


/// Function name  : onScriptDocumentViewError
// Description     : Display the error associated with the line used to invoke the context menu
// 
// SCRIPT_DOCUMENT*    pDocument   : [in] ScriptDocument
// 
VOID  onScriptDocumentViewError(SCRIPT_DOCUMENT*  pDocument)
{
   ERROR_QUEUE*  pErrorQueue;    // ErrorQueue
   ERROR_STACK*  pTopError;      // First error in queue
   TCHAR*        szTitle;        // Message title

   // Prepare
   pErrorQueue = CodeEdit_GetCaretLineError(pDocument->hCodeEdit);
   pTopError   = firstErrorQueue(pErrorQueue);

   // Generate title
   szTitle = utilCreateStringf(64, TEXT("MSCI Script Editor %s"), pTopError ? identifyErrorTypeString(pTopError->eType) : TEXT(""));

   // [CHECK] Are there multiple errors?
   if (getQueueItemCount(pErrorQueue) > 1)
      // [MULTIPLE] Display queue dialog
      displayErrorQueueDialog(NULL, pErrorQueue, szTitle);
   else
      // [SINGLE] Display stack dialog
      displayErrorMessageDialog(NULL, pTopError, szTitle, MDF_OK);

   // Cleanup
   utilDeleteString(szTitle);
}


/// ////////////////////////////////////////////////////////////////////////////////////////////////////
///                                          WINDOW PROCEDURE
/// ////////////////////////////////////////////////////////////////////////////////////////////////////

/// Function name  : wndprocScriptDocument
// Description     : ScriptDocument window procedure
//
//
LRESULT   wndprocScriptDocument(HWND  hDialog, UINT  iMessage, WPARAM  wParam, LPARAM  lParam)
{
   DOCUMENT_OPERATION*  pOperationData;
   SCRIPT_DOCUMENT*     pDocument;
   MEASUREITEMSTRUCT*   pItemSize;
   CREATESTRUCT*        pCreationData;
   ERROR_STACK*         pError;
   POINT                ptCursor;
   SIZE                 siWindow;
   LRESULT              iResult;
   
   // Prepare
   TRACK_FUNCTION();
   iResult = 0;

   /// [GUARD BLOCK]
   __try
   {
      // Get document data
      pDocument = (SCRIPT_DOCUMENT*)GetWindowLong(hDialog, 0);

      // Examine message
      switch (iMessage)
      {
      /// [CREATE] 
      case WM_CREATE:
         // Prepare
         pCreationData = (CREATESTRUCT*)lParam;
         pDocument = (SCRIPT_DOCUMENT*)pCreationData->lpCreateParams;

         // Init dialog
         onScriptDocumentCreate(pDocument, hDialog);
         break;

      /// [DESTROY] - Delete document data
      case WM_DESTROY:
         onScriptDocumentDestroy(pDocument);
         break;

      /// [COMMAND PROCESSING]
      case WM_COMMAND:
         if (!onScriptDocumentCommand(pDocument, LOWORD(wParam), HIWORD(wParam)))
            // [UNHANDLED] Call default window proc
            iResult = DefWindowProc(hDialog, iMessage, wParam, lParam);
         break;

      /// [NOTIFICATION]
      case WM_NOTIFY:
         if (!onScriptDocumentNotify(pDocument, (NMHDR*)lParam))
            // [UNHANDLED] Call default window proc
            iResult = DefWindowProc(hDialog, iMessage, wParam, lParam);
         break;

      /// [RESIZE] - Resize tab to the size of the tab control
      case WM_SIZE:
         siWindow.cx = LOWORD(lParam);
         siWindow.cy = HIWORD(lParam);
         
         onScriptDocumentResize(pDocument, &siWindow);
         break;

      /// [CONTEXT MENU]
      case WM_CONTEXTMENU:
         ptCursor.x = GET_X_LPARAM(lParam);
         ptCursor.y = GET_Y_LPARAM(lParam);
         onScriptDocumentContextMenu(pDocument, hDialog, &ptCursor, (HWND)wParam);
         break;

      /// [MENU ITEM HOVER] Forward messages from CodeEdit up the chain to the Main window
      case WM_MENUSELECT:
         sendAppMessage(AW_MAIN, WM_MENUSELECT, wParam, lParam);
         break;

      /// [RECEIVE/LOSE FOCUS]
      case WM_SETFOCUS:    onScriptDocumentReceiveFocus(pDocument, hDialog);  break;
      case WM_KILLFOCUS:   onScriptDocumentLoseFocus(pDocument, hDialog);     break;

      /// [CONTEXT HELP]
      case WM_HELP:
         onScriptDocumentHelp(pDocument, hDialog, (HELPINFO*)lParam);
         break;

      /// [KEYBOARD INPUT] Request keyboard input
      case WM_GETDLGCODE:
         iResult = DLGC_WANTALLKEYS;
         break;

      /// [CUSTOM MENU/CUSTOM COMBO]
      case WM_DRAWITEM:    onWindow_DrawItem((DRAWITEMSTRUCT*)lParam);                     break;
      case WM_DELETEITEM:  onWindow_DeleteItem((DELETEITEMSTRUCT*)lParam);                 break;
      case WM_MEASUREITEM: pItemSize = (MEASUREITEMSTRUCT*)lParam; 
                           pItemSize->CtlType == ODT_COMBOBOX ? onWindow_MeasureComboBox(pItemSize, (IMAGE_TREE_SIZE)20, ITS_MEDIUM) : onWindow_MeasureItem(hDialog, pItemSize);  break;

      /// [DOCUMENT LOADED/SAVED]
      case UN_OPERATION_COMPLETE:
         // Prepare
         pOperationData = (DOCUMENT_OPERATION*)lParam;

         // Examine operation type
         if (pOperationData->eType == OT_LOAD_SCRIPT_FILE)
            onScriptDocumentLoadComplete(pDocument, pOperationData);
         else if (pOperationData->eType == OT_SAVE_SCRIPT_FILE)
            onScriptDocumentSaveComplete(pDocument, pOperationData);
         else if (pOperationData->eType == OT_VALIDATE_SCRIPT_FILE)
            onScriptDocumentValidationComplete(pDocument, pOperationData);
         break;

      /// [DOCUMENT PROPERTY CHANGED]
      case UN_PROPERTY_UPDATED:
         onScriptDocumentPropertyChanged(pDocument, wParam);
         break;

      /// [GET SCRIPT VERSION]
      case UM_GET_SCRIPT_VERSION:
         iResult = onScriptDocumentGetScriptVersion(pDocument, (GAME_VERSION*)lParam);
         break;

      /// [QUERY DOCUMENT COMMAND]
      case UM_QUERY_DOCUMENT_COMMAND:
         iResult = onScriptDocumentQueryCommand(pDocument, wParam);
         break;

      /// [INSERT RESULT] Forward to CodeEdit
      case UM_INSERT_TEXT_AT_CARET:
         CodeEdit_InsertTextAtCaret(pDocument->hCodeEdit, (CONST TCHAR*)lParam);
         break;

      /// [CODE-EDIT CHANGED]
      case UN_CODE_EDIT_CHANGED:
         // [SELECTION CHANGED]
         if (wParam INCLUDES CCF_SELECTION_CHANGED)
            onScriptDocumentSelectionChange(pDocument);

         // [TEXT CHANGED]
         if (wParam INCLUDES CCF_TEXT_CHANGED)
            onScriptDocumentTextChange(pDocument);

         // [SCOPE CHANGED]
         if (wParam INCLUDES CCF_SCOPE_CHANGED)
            onScriptDocumentScopeChange(pDocument, (CODE_EDIT_LABEL*)lParam);
         break;

      /// [CODE-EDIT SCRIPT-ARGUMENTS]
      case UN_CODE_EDIT_REQUEST_ARGUMENTS:
         onScriptDocumentRequestArguments(pDocument, (COMMAND*)lParam);
         break;

      /// [PREFERENCES CHANGED]
      case UN_PREFERENCES_CHANGED:
         onScriptDocumentPreferencesChanged(pDocument);
         break;

      // [UNHANDLED]
      default:
         iResult = DefWindowProc(hDialog, iMessage, wParam, lParam);
         break;
      }
   }
   /// [EXCEPTION HANDLER]
   __except (generateExceptionError(GetExceptionInformation(), pError))
   {
      // [ERROR] "An unidentified and unexpected critical error has occurred in the document object of script '%s'"
      enhanceError(pError, ERROR_ID(IDS_EXCEPTION_SCRIPT_DOCUMENT), (pDocument ? getDocumentFileName(pDocument) : TEXT("Unknown")));
      displayException(pError);
   }
   
   // Return result
   END_TRACKING();
   return iResult;
}


